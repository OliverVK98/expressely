{
  "notifications": [
    {
      "id": "1",
      "title": "Уведомление 1",
      "description": "Произошло какое-то событие",
      "userId": "1"
    }
  ],
  "articles": [
    {
      "id": "1",
      "title": "Microfrontend. Server fragments — frontend as it supposed to be",
      "subtitle": "When you think about the frontend - how should it look like in the ideal world?",
      "img": "https://images.clickittech.com/2020/wp-content/uploads/2022/06/23153203/MicroFrontend-banner-63.jpg",
      "views": 59,
      "createdAt": "26.04.2022",
      "userId": "1",
      "type": [
        "IT",
        "React"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "When you think about the frontend - how should it look like in the ideal world? I see it as",
          "paragraphs": [
            "1. Single Page Application (SPA) - user don't wait when you load the whole set of assets again when you go to the next route - best UX",
            "2. Server-side rendering (SSR) - user receives the page content faster since it's rendered on server and some of the content is cached on CDN - best SEO and great performance",
            "3. Independent deployments by different teams - factor that is usually skipped and underestimated but it gives you as a developer the confidence you don't break the whole site once your deployment is failed or if it has bugs, you also don't wait when other team member's build is finished and nobody accidentally touches your area of responsibility - great DX, no regression testing is required",
            "What does market provide today?",
            "⭐️ ⭐️ ❌ SPA + SSR but no independent deployments",
            "⭐️ ❌ ⭐️ SPA without SSR but with independent deployments",
            "❌ ⭐️ ⭐️ not a SPA but SSR + independent deployments",
            "In this article i',ll describe a way how to have all three on the example of the react application."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "⭐️ ⭐️ ⭐️ SPA + SSR + Independent deployments by different teams",
          "paragraphs": [
            "Working demo is here: https://github.com/egorvoronov/react-microfrontend",
            "First of all, let's imagine we develop a great site and we have 2 teams, let's split them and ask Team A to focus on a Header component where Team B could focus on a Footer component. We also would like to have all the components to be rendered together when our user visits our site. Let's create 3 different folders for the 3 use-cases above:",
            "1. appRenderer - where we glue our fragments",
            "2. fragmentHeader - where Team A develops a great header",
            "3. fragmentFooter - where Team B develops a great footer"
          ]
        },
        {
          "id": "3",
          "type": "IMAGE",
          "src": "https://hsto.org/getpro/habr/upload_files/7cd/3f9/74f/7cd3f974f6bdec165344df134eb90e1d.png"
        },
        {
          "id": "4",
          "type": "TEXT",
          "paragraphs": [
            "Let's consider appRenderer",
            "It's just a simple application that have 2 build points, one for server and one for client using webpack.",
            "For client's build we'll add ModuleFederationPlugin to make sure that we're able to rehydrate the rendered on a server content once the page is in the user's browser:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "new ModuleFederationPlugin({\n    name: 'appRenderer',\n    filename: \"remoteEntry.js\",\n    exposes: {\n        './AppRendererContextForFragments': './context/AppRendererContextForFragments',\n    },\n    remotes: {\n        fragmentHeader: `fragmentHeader@${getRemoteEntryUrl(3001)}`,\n        fragmentFooter: `fragmentFooter@${getRemoteEntryUrl(3002)}`,\n    },\n    shared: [\n        {\n            react: { singleton: true, requiredVersion: deps.react },\n            'react-dom': { singleton: true, requiredVersion: deps[ 'react-dom' ] }\n        },\n    ],\n})"
        },
        {
          "id": "6",
          "type": "TEXT",
          "paragraphs": [
            "That would allow us to use the header fragment in our application like below:"
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "// ...\nimport FragmentHeader from 'fragmentHeader/Fragment';\n// ...\n\nconst Content = ({ state }) => {\n    return (\n        <AppRendererContextForFragments.Provider\n            value={{\n                userAgent: state.userAgent,\n            }}\n        >\n            <FragmentHeader firstname={state.firstname} />\n            <div\n                style={{\n                    height: '300px',\n                    backgroundColor: 'grey',\n                    textAlign: 'center',\n                    paddingTop: '100px',\n                }}\n            >\n                Great Body of the page (Another fragment)\n            </div>\n            <FragmentFooter />\n        </AppRendererContextForFragments.Provider>\n    );\n};"
        },
        {
          "id": "8",
          "type": "TEXT",
          "paragraphs": [
            "I'm using context there to pass userAgent also to make sure that server is able to render mobile version of the header and client is able to rehydrate the same, but that's not an important part here."
          ]
        },
        {
          "id": "9",
          "type": "TEXT",
          "paragraphs": [
            "From server side we also need to know how to handle that import FragmentHeader from 'fragmentHeader/Fragment';"
          ]
        },
        {
          "id": "10",
          "type": "TEXT",
          "paragraphs": [
            "❗️And the main challenge goes here, we'll touch this topic again below in the article but here is the short story. Default webpack module federation feature gives us ability to use fragments on server BUT such files that consists of fragments are supposed to be in the same filesystem as appRenderer file with server code - which is not great since it's not clear how to deploy the new version of the header independently without affecting the main application. There are some options, for example, we could use shared volume on our cluster and just replace the files there but appRenderer server is already running and all the variables inside that server are already initialised, so, without the rude hacks it's not possible to replace header component on a server without a restart or redeploy of the main application (appRenderer server) - so it's not an independent deployment anymore."
          ]
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraphs": [
            "So, we need another solution. Ideally, it would be great if appRenderer is a standalone application but once it sees import FragmentHeader from 'fragmentHeader/Fragment'; it just sends the request to some other server and gets the html back and just embeds that html to the resulting response that would be sent to the user to his browser."
          ]
        },
        {
          "id": "12",
          "type": "TEXT",
          "paragraphs": [
            "To do that, here is the example of plugin that I wrote. It's really naive, but essentially gives us what we want, once it sees import FragmentHeader from 'fragmentHeader/Fragment'; - it just makes the http request to fetch the server html for it. Let's add that plugins (called ReactMFRemoteFragmentPlugin) to the server build:\n\n"
          ]
        },
        {
          "id": "13",
          "type": "CODE",
          "code": "plugins: [\n    new ModuleFederationPlugin({\n        name: \"appRenderer\",\n        library: { type: \"commonjs-module\" },\n        filename: 'remoteContainer.js',\n        exposes: {\n            './AppRendererContextForFragments': './context/AppRendererContextForFragments',\n        },\n        remotes: {\n            fragmentHeader: path.resolve(\n                __dirname,\n                \"./dist/fragmentHeader/remoteContainer.js\"\n            ),\n            fragmentFooter: path.resolve(\n                __dirname,\n                \"./dist/fragmentFooter/remoteContainer.js\"\n            )\n        },\n        shared: [\n            // { react: { singleton: true }, \"react-dom\": { singleton: true } }\n            './context/AppRendererContextForFragments'\n        ],\n    }),\n    new webpack.DefinePlugin({\n        'process.env.REACT_APP_IS_SERVER': JSON.stringify(process.env.REACT_APP_IS_SERVER),\n    }),\n    new ReactMFRemoteFragmentPlugin({\n        name: 'fragmentHeader',\n        url: 'http://localhost:3001'\n    }),\n    new ReactMFRemoteFragmentPlugin({\n        name: 'fragmentFooter',\n        url: 'http://localhost:3002'\n    }),\n],"
        },
        {
          "id": "14",
          "type": "TEXT",
          "paragraphs": [
            "As you see, at the bottom we add ReactMFRemoteFragmentPlugin specifying urls from which we'll derive the content for the fragments. Again, plugin itself is really dummy but works which is exactly what we want for our POC. You could also find the source code of that plugin in npm and in the repo if you're interested in the details. We'll also slightly cover it below in the article as well.",
            "That's all what we need for appRenderer. Let's switch to fragments.",
            "Considering fragmentHeader, here are the main points you need to know:",
            "1. we use the empty client/index.js file there - since we don't need a standalone build for the header for now, we're interested only in the fragment output that webpack ModuleFederation plugin would generate for us.",
            "2. we use the default ModuleFederationPlugin there, nothing fancy for the client's build, such files will be used for the rehydration process only in the user's browser after content is delivered by appRenderer server:"
          ]
        },
        {
          "id": "15",
          "type": "CODE",
          "code": "new ModuleFederationPlugin({\n    name: 'fragmentHeader',\n    library: { type: 'var', name: 'fragmentHeader' },\n    remotes: {\n        appRenderer: `appRenderer@${getRemoteEntryUrl(3000)}`,\n    },\n    filename: 'remoteEntry.js',\n    exposes: {\n        './Fragment': './src/Fragment',\n    },\n    shared: {\n        react: { singleton: true, requiredVersion: deps.react },\n        'react-dom': { singleton: true, requiredVersion: deps['react-dom'] }\n    },\n}),"
        },
        {
          "id": "16",
          "type": "TEXT",
          "paragraphs": [
            "3. and the last important point here, that we don't use ModuleFederationPlugin for the server's build in fragments since we won't be using standard server support of ModuleFederationPlugin because of the reason named above - it does not support independent deployments of the fragments. When we talk about fragments server code we're only interested in html code generated by fragment's server code using the Header fragment that we'll just embed to the appRenderer server's html response later. And to make it happened, we just need to write the following naive server for fragments using express:"
          ]
        },
        {
          "id": "17",
          "type": "CODE",
          "code": "const app = express();\n\napp.get('*', (req, res, next) => {\n    setTimeout(() => {\n        res.send({\n            htmlFragment: ReactDOMServer.renderToString(<Fragment {...req.query}/>),\n        link,\n    });\n    }, 5000);\n})"
        },
        {
          "id": "18",
          "type": "TEXT",
          "paragraphs": [
            "I'm adding 5 seconds delay here just to simulate the async nature of the requests. All the fetching and embedding magic could be found in the modules folder (webpack-plugin is published to npm as react-mf-remote-fragment).",
            "2 words on the magic 🪄 there. Once server sees import FragmentHeader from 'fragmentHeader/Fragment'; in appRenderer server code it just uses the default module federation server feature looking for the server version of header fragment in filesystem but the issue, as highlighted above, is that we can't use header code there since that would be the same filesystem and our inability to independently deploy header later since we won't be able to replace the header code without app restart or rude hacks. But we, instead, could use the plugin that will generate a file with the component, essentially just a wrapper, and the responsibility of that component would be just to derive the exact header code & components from the proper url. So, frankly speaking, we, actually, use the default ModuleFederation server support that looks for the header fragment in the filesystem but we use it not for delivering the exact header code but for delivery of the wrapper fragment - code that would know from where to fetch that header code from. Such file is being generated during the build phase and since the responsibility of that file is not changed time over time we could generate it once and just update the fragment's server that delivers the proper html now.",
            "🙋🏻‍♀️ All good so far, but how our server rendering phase would stop and wait once we go to the other server for header's html content? React usual standard methods like renderToString & renderToStaticMarkup do not support it and is considered as one-go operation like rendered and then sent to the browser.",
            "🤯 Standard methods don't support it but we'll use the new methods that react v18 brought to us. Essentially, that wrapper code that was generated is just a react component that uses new react v18 feature of React.Suspense. React.Suspense started supporting server-side rendering and that Suspense is being resolved once the call to other server is done and html is translated back to react component that is rendered again to html on appRenderer during the content is served back to the user's browser. If you're interested in the details, just look to the modules folder, all magic is in these 2 files:"
          ]
        },
        {
          "id": "19",
          "type": "IMAGE",
          "src": "https://hsto.org/r/w1560/getpro/habr/upload_files/a32/4af/655/a324af6553c8f271ae19fe3ed3d17a11.png"
        },
        {
          "id": "20",
          "type": "TEXT",
          "paragraphs": [
            "And as a final step, to prevent the react to emit us an error that server rendered content does not differ from the client render, we need to return the same content as it was rendered by a server. To make it happened, there is another helper react component container was created that wraps a Header component for client only. On a server we need the clean component that we just render to html and return back but on a client we need a clean component plus a wrapper that adds the missing tags/parts that are not part of the clean component but was returned back from the server. Here is how we use it in our main entry file Fragment.js on every fragment:"
          ]
        },
        {
          "id": "21",
          "type": "CODE",
          "code": "function Fragment() {\n    if (process.env.REACT_APP_IS_SERVER === '1') {\n        return <Header />;\n    } else {\n        return (\n            <FragmentClientContainer name=\"fragmentHeader\">\n                <Header />\n            </FragmentClientContainer>\n        );\n    }\n}"
        },
        {
          "id": "22",
          "type": "TEXT",
          "paragraphs": [
            "FragmentClientContainer just makes sure that code is the same for server and client and just waits the initialisation of the fragment which could be useful once you start using lazy loadable components inside one or another fragment, for example."
          ]
        }
      ]
    },
    {
      "id": "2",
      "title": "Factory Method Design Pattern in GoLang",
      "subtitle": "Unlocking Code Efficiency",
      "img": "https://miro.medium.com/v2/resize:fit:720/0*wG-8jL62Bgp1QsgT",
      "views": 293,
      "createdAt": "05.29.2023",
      "userId": "1",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Introduction",
          "paragraphs": [
            "Hello, fellow developers! Today we’re delving into the intriguing world of design patterns, focusing on the Factory Method Pattern. If you’re a GoLang enthusiast or a curious tech aficionado, this post will offer valuable insights and practical examples. So please grab a coffee, sit back, and start exploring!"
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "What is the Factory Method Design Pattern?",
          "paragraphs": [
            "In software development, Design Patterns are the solutions to recurring common problems. One of these is the Factory Method Pattern, a creational design pattern providing an interface for creating objects in a superclass but letting subclasses alter the type of objects that will be created.\n\n"
          ]
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Why Use the Factory Method Pattern in GoLang?",
          "paragraphs": [
            "This brings us to our big question — why should you use the Factory Method Pattern in GoLang? The answer is quite simple. GoLang, with its simplicity and efficiency, lends itself perfectly to implementing design patterns like the Factory Method.",
            "1. Flexibility and Decoupling: The Factory Method Pattern helps you attain flexibility and decoupling. Instead of calling a constructor directly to create an object, you delegate that responsibility to a factory method. This decouples the specific classes of objects you create from the parts of your application that use these objects.",
            "2. Ease of Maintenance: With the Factory Method Pattern, any changes needed (like using a different class constructor) can be done in the factory method without affecting other application parts. This makes code maintenance much more straightforward.",
            "3. Code Reusability and Clarity: This pattern encourages code reusability and makes the code more readable and understandable."
          ]
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "Practical Examples of the Factory Method Pattern in GoLang",
          "paragraphs": [
            "Let’s get practical now! Here are three real-world scenarios where you could effectively implement the Factory Method Pattern in GoLang.",
            "1. Database Connection Factory: Different databases (MySQL, PostgreSQL, MongoDB) require different connection processes, yet the end goal (a connection instance) remains the same. The Factory Method Pattern shines here by providing a uniform way to create different database connections without littering your application code with details about each specific database connection process."
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "type Database interface {\n    Connect() error\n}\n\ntype Factory struct{}\n\nfunc (f *Factory) CreateDatabase(dbType string) Database {\n    switch dbType {\n    case \"MySQL\":\n        return &MySQLDatabase{}\n    case \"PostgreSQL\":\n        return &PostgreSQLDatabase{}\n    default:\n        return nil\n    }\n}"
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Practical Examples of the Factory Method Pattern in GoLang",
          "paragraphs": [
            "2. Logger Factory: Let’s say your application uses different types of loggers (Console, File, Network). Again, each requires a different creation process, but all provide the same functionality: logging. Utilizing the Factory Method Pattern allows you to create any necessary logger without coupling your application code to specific logger classes."
          ]
        },
        {
          "id": "7",
          "type": "CODE",
          "code": "type Logger interface {\n    Log(message string)\n}\n\ntype LoggerFactory struct{}\n\nfunc (lf *LoggerFactory) CreateLogger(loggerType string) Logger {\n    switch loggerType {\n    case \"Console\":\n        return &ConsoleLogger{}\n    case \"File\":\n        return &FileLogger{}\n    default:\n        return nil\n    }\n}"
        },
        {
          "id": "8",
          "type": "TEXT",
          "title": "Practical Examples of the Factory Method Pattern in GoLang",
          "paragraphs": [
            "3. Payment Method Factory: Consider an e-commerce application that supports various payment methods like Credit Cards, PayPal, and Cryptocurrency. Using the Factory Method Pattern, you can smoothly create a suitable payment method object based on user preference while decoupling the creation logic from the main application code."
          ]
        },
        {
          "id": "9",
          "type": "CODE",
          "code": "type PaymentMethod interface {\n    Pay(amount float32) string\n}\n\ntype PaymentMethodFactory struct{}\n\nfunc (pmf *PaymentMethodFactory) GetPaymentMethod(method string) (PaymentMethod, error) {\n    switch method {\n    case \"CreditCard\":\n        return new(CreditCard), nil\n    case \"PayPal\":\n        return new(PayPal), nil\n    default:\n        return nil, errors.New(\"Invalid payment method\")\n    }\n}"
        },
        {
          "id": "10",
          "type": "TEXT",
          "title": "Practical Examples of the Factory Method Pattern in GoLang",
          "paragraphs": [
            "I hope this dive into the Factory Method Pattern in GoLang was valuable and illuminating. Design patterns are not rigid rules but flexible approaches to solving everyday problems. Use them as guidelines, not gospel, and always choose the best tool for your needs. Happy coding!"
          ]
        }
      ]
    },
    {
      "id": "3",
      "title": "7 Skills Needed to Become a Blockchain Developer in 2023",
      "subtitle": "Build a Career in Blockchain Technology",
      "img": "https://miro.medium.com/v2/resize:fit:720/0*cy7IvA4O5JwOEHhB.gif",
      "views": 87,
      "createdAt": "04.19.2023",
      "userId": "1",
      "type": [
        "IT",
        "Blockchain"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "paragraphs": [
            "As the world continues to embrace new technologies, the demand for skilled professionals in various fields has increased. Blockchain technology is one of the most rapidly evolving fields, and blockchain developers are highly sought after. Blockchain technology is used in various industries, including finance, healthcare, and supply chain management, among others. In this article, we will look at seven essential skills needed to become a blockchain developer."
          ]
        },
        {
          "id": "1",
          "type": "TEXT",
          "title": "1. Command Line",
          "paragraphs": [
            "The command line is an essential tool for blockchain developers. It is a text-based interface that allows developers to communicate with the computer’s operating system. Command line tools such as Git, Geth, and NPM are used by blockchain developers to manage code, test smart contracts, and interact with the Ethereum network.",
            "Git is a version control system that allows developers to keep track of changes made to their code. It is used to collaborate with other developers and manage code changes. Geth is a command line interface for running Ethereum nodes, and NPM is a package manager for Node.js.",
            "To become a blockchain developer, you must have a good understanding of the command line and be comfortable working with it."
          ]
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "2. Javascript",
          "paragraphs": [
            "JavaScript is a high-level programming language used in web development. It is also used in blockchain development to create smart contracts and decentralized applications (DApps). Ethereum, one of the most popular blockchain platforms, uses a programming language called Solidity, which is similar to JavaScript.",
            "As a blockchain developer, you must have a good understanding of JavaScript and its syntax. You must also be familiar with various JavaScript frameworks, such as React and Angular, which are used to develop frontend applications for DApps."
          ]
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "3. Node.js",
          "paragraphs": [
            "Node.js is an open-source, cross-platform runtime environment used to build server-side applications. It is built on top of Google’s V8 JavaScript engine and allows developers to run JavaScript on the server-side. Node.js is used in blockchain development to build and test smart contracts and interact with the Ethereum network."
          ]
        },
        {
          "id": "5",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:720/format:webp/0*ixW6nFAwGYpTlKch.png"
        },
        {
          "id": "6",
          "type": "TEXT",
          "paragraphs": [
            "As a blockchain developer, you must have a good understanding of Node.js and its libraries. You must also be familiar with various Node.js frameworks, such as Express and Koa, which are used to build server-side applications for DApps."
          ]
        },
        {
          "id": "7",
          "type": "TEXT",
          "title": "4. Blockchain Basics",
          "paragraphs": [
            "To become a blockchain developer, you must have a good understanding of blockchain basics. You must know how blockchain works, how blocks are created, and how transactions are verified. You must also be familiar with the various types of blockchain, such as public, private, and consortium blockchains.",
            "In a nutshell, a blockchain is a distributed ledger that is used to record transactions. It consists of a series of blocks, each containing a list of transactions. Each block is connected to the previous block, forming a chain of blocks, hence the name blockchain. Once a block is added to the blockchain, it cannot be modified, ensuring that the data stored on the blockchain is immutable and tamper-proof.",
            "Fundamentally, blockchain technology has several unique features that make it suitable for various applications. These features include transparency, security, decentralization, immutability, and consensus. Transactions on the blockchain are transparent, meaning that anyone can view the transactions on the blockchain, but the identity of the sender and receiver is anonymous. The security of the blockchain is ensured through the use of cryptographic algorithms that protect the data stored on the blockchain from being tampered with or hacked.",
            "Decentralization is one of the most significant advantages of blockchain technology. The blockchain is not controlled by a single entity or authority, but by a network of nodes that work together to validate transactions and maintain the integrity of the blockchain. Immutability ensures that once a transaction is added to the blockchain, it cannot be modified or deleted, making the data on the blockchain trustworthy and reliable.",
            "Consensus in blockchain is another critical feature. It ensures that all nodes in the network agree on the state of the blockchain, making it difficult for malicious actors to manipulate the data on the blockchain. Different consensus algorithms are used in blockchain technology, such as proof-of-work and proof-of-stake."
          ]
        },
        {
          "id": "8",
          "type": "TEXT",
          "title": "5. Solidity",
          "paragraphs": [
            "Solidity is a programming language used to write smart contracts on the Ethereum blockchain. It is similar to JavaScript in syntax and is used to define the rules of a smart contract. Smart contracts are self-executing contracts that automatically execute when certain conditions are met.",
            "As a blockchain developer, you must have a good understanding of Solidity and its syntax. You must also be familiar with the various Solidity libraries and tools, such as Remix and Truffle, which are used to develop and test smart contracts."
          ]
        },
        {
          "id": "9",
          "type": "TEXT",
          "title": "6. Web3.js",
          "paragraphs": [
            "Web3 is a JavaScript library used to interact with the Ethereum network. It provides a simple and easy-to-use interface for developers to interact with the Ethereum network and execute transactions. Web3.js is used in blockchain development to build frontend applications for DApps.",
            "As a blockchain developer, you must have a good understanding of Web3.js and its syntax. You must also be familiar with the various Web3.js functions, such as sending transactions and reading data from the blockchain."
          ]
        },
        {
          "id": "10",
          "type": "TEXT",
          "title": "7. Truffle Suite",
          "paragraphs": [
            "Truffle Suite is a development framework used to build and deploy decentralized applications on the Ethereum network. It provides a suite of tools and libraries that make it easy for developers to develop, test, and deploy smart contracts and DApps.",
            "Truffle Suite includes several tools, such as Truffle, Ganache, and Drizzle. Truffle is a development framework used to build and test smart contracts. Ganache is a personal blockchain used for testing smart contracts, and Drizzle is a collection of libraries used to build frontend applications for DApps.",
            "As a blockchain developer, you must have a good understanding of Truffle Suite and its various tools. You must also be familiar with the various Truffle Suite commands, such as compiling contracts and deploying contracts to the Ethereum network."
          ]
        },
        {
          "id": "11",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:720/format:webp/0*_LuAAgP9x4T0RjBw.png"
        },
        {
          "id": "12",
          "type": "TEXT",
          "title": "Conclusion",
          "paragraphs": [
            "In conclusion, becoming a blockchain developer requires a wide range of skills, including a good understanding of the command line, JavaScript, Node.js, blockchain basics, Solidity, Web3.js, and Truffle Suite. These skills are essential for developing and deploying smart contracts and decentralized applications on the Ethereum network.",
            "As the demand for blockchain developers continues to increase, it is essential for aspiring developers to invest time and effort in learning these skills. Blockchain technology is still in its early stages, and there is a vast opportunity for developers to innovate and create new applications that can revolutionize various industries.",
            "Therefore, if you are interested in becoming a blockchain developer, it is essential to start learning these skills today and keep up with the latest developments in the field. With dedication, hard work, and continuous learning, you can become a successful blockchain developer and contribute to the growth and development of the blockchain ecosystem."
          ]
        }
      ]
    },
    {
      "id": "4",
      "title": "AI will NOT replace front-end developers!",
      "img": "https://miro.medium.com/v2/resize:fit:720/format:webp/1*4jl3ClZJJL3D3SaU4Z1dtw.png",
      "views": 498,
      "createdAt": "04.19.2021",
      "userId": "1",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Introduction",
          "paragraphs": [
            "AI, or Artificial Intelligence, refers to the simulation of human intelligence in machines that are programmed to perform tasks that typically require human intelligence. AI systems are designed to perceive their environment, reason and learn from the available data, and make decisions or take actions to achieve specific goals.",
            "While AI and automation can enhance certain aspects of front-end development, they cannot completely replace the role of front-end developers. Front-end development involves a combination of technical skills, creativity, problem-solving, and user-centric thinking that requires human expertise.",
            "AI technologies may assist with tasks like code generation, automated testing, or performance optimization, BUT the critical thinking, decision-making, and adaptability of human developers are irreplaceable.",
            "Reasons why AI will not replace front-end developers:"
          ]
        },
        {
          "id": "2",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:286/format:webp/1*gZgEuty6x5ORvNpq8RhrwA.png"
        },
        {
          "id": "3",
          "type": "TEXT",
          "paragraphs": [
            "Creativity: Front-end development requires creative thinking to design visually appealing and user-friendly interfaces. AI lacks the creative intuition and artistic sense that human developers possess."
          ]
        },
        {
          "id": "4",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*U7CsgxnV5i7TxVaOvYBG3g.png"
        },
        {
          "id": "5",
          "type": "TEXT",
          "paragraphs": [
            "User Experience: Front-end developers focus on creating seamless and intuitive user experiences. This involves understanding user needs, behavior, and emotions, which requires empathy and human judgment."
          ]
        },
        {
          "id": "6",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*ou1Gu_ncS5L_KgvPWk9SuQ.png"
        },
        {
          "id": "7",
          "type": "TEXT",
          "paragraphs": [
            "Problem-solving: Front-end developers are skilled problem solvers who can analyze complex requirements, find optimal solutions, and address user experience challenges. AI, while capable of automating certain tasks, cannot replicate the comprehensive problem-solving abilities of human developers."
          ]
        },
        {
          "id": "8",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*uu_MpPcYwo-RNiIQSUoO3g.jpeg"
        },
        {
          "id": "9",
          "type": "TEXT",
          "paragraphs": [
            "Adaptability: Front-end development often involves adapting to changing technologies, design trends, and user expectations. Human developers can quickly learn and adopt new tools, frameworks, and techniques, while AI systems require human intervention to update and adapt."
          ]
        },
        {
          "id": "10",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*QCDVlzgt5hLiDJ80-Q8z4Q.png"
        },
        {
          "id": "11",
          "type": "TEXT",
          "paragraphs": [
            "Collaboration: Front-end developers work closely with designers, back-end developers, and stakeholders to bring a project to life. Effective communication, teamwork, and understanding of multiple perspectives are vital, which AI cannot replicate."
          ]
        },
        {
          "id": "12",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*0VqcXFsmzzvdDZyFKokpFw.png"
        },
        {
          "id": "13",
          "type": "TEXT",
          "paragraphs": [
            "Contextual Decision-making: Front-end developers make design and implementation decisions based on contextual factors, such as the target audience, business goals, and branding requirements. AI lacks the contextual understanding necessary for making informed decisions."
          ]
        },
        {
          "id": "14",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*kG5y7iZrsRCL-pFKzkej_w.png"
        },
        {
          "id": "15",
          "type": "TEXT",
          "paragraphs": [
            "Continuous Learning: Front-end developers constantly learn and improve their skills to keep up with the evolving web development landscape. They stay updated on new technologies, best practices, and emerging trends. AI systems, while capable of learning, rely on human input and training data."
          ]
        },
        {
          "id": "16",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:550/format:webp/1*3pZl0sNkt9jlNufYI73iXQ.jpeg"
        },
        {
          "id": "17",
          "type": "TEXT",
          "paragraphs": [
            "Quality Assurance: Front-end developers ensure the quality and performance of web applications through testing, debugging, and optimization. Their critical thinking and attention to detail are essential in delivering high-quality user experiences."
          ]
        },
        {
          "id": "18",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:450/format:webp/1*LtA08XdJmr8UOvD7Ax7nDQ.jpeg"
        },
        {
          "id": "19",
          "type": "TEXT",
          "paragraphs": [
            "Human Touch: Front-end development involves creating experiences that resonate with human users. The human touch, empathy, and understanding of human psychology are essential elements that AI cannot replicate."
          ]
        },
        {
          "id": "20",
          "type": "IMAGE",
          "src": "https://miro.medium.com/v2/resize:fit:598/format:webp/1*xSUNLfEft9F5RrOUhCprPA.png"
        },
        {
          "id": "21",
          "type": "TEXT",
          "paragraphs": [
            "Future-proofing: Front-end developers possess the adaptability and problem-solving skills to navigate the ever-changing landscape of technology. They can envision future user needs and anticipate trends, ensuring that applications remain relevant and innovative.",
            "In summary, AI can be a valuable tool for front-end developers, but it cannot replace the expertise, creativity, and human touch that they bring to the table. The collaboration between AI and front-end developers has the potential to result in more efficient and innovative solutions in the field of web development."
          ]
        }
      ]
    },
    {
      "id": "5",
      "title": "Understanding the Role of Babel",
      "img": "https://miro.medium.com/v2/resize:fit:720/format:webp/1*ci7Opy7BG-xsZH782UqrCQ.png",
      "views": 303,
      "createdAt": "04.19.2020",
      "userId": "1",
      "type": [
        "IT"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "title": "Exploring Babel: A Must-Have for Web Developers",
          "paragraphs": [
            "As an aspiring web developer, you’ve likely spent hours meticulously constructing applications using modern JavaScript syntax, only to find it’s incompatible with some browsers. This frustration is common in the world of web development. Thankfully, there’s a tool that can help overcome this problem: Babel. (See full docs: https://babeljs.io/)",
            "Babel is an open-source JavaScript compiler that plays a central role in numerous web applications. It bridges the gap between cutting-edge JavaScript code and older browsers that struggle to understand it. Babel transforms ECMAScript 2015+ (ES6+) code into a backward-compatible version, a process often referred to as “transpiling.”",
            "Babel can perform various tasks, including syntax transformation, filling missing features in your target environment through a third-party polyfill like core-js, conducting source code transformations (codemods), and more. It’s important to note that Babel’s role goes beyond syntax conversion — it also brings forward compatibility for new native APIs.",
            "Different Javascript versions have different syntaxes:"
          ]
        },
        {
          "id": "2",
          "type": "CODE",
          "code": "Example:\n// Babel Input: ES2015 arrow function\n    [1, 2, 3].map(n => n + 1);\n\n// Babel Output: ES5 equivalent\n[1, 2, 3].map(function(n) {\n    return n + 1;\n});"
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Babel’s Application in the Tech Ecosystem",
          "paragraphs": [
            "Babel’s significance and versatility can be observed through its compatibility with various modern frameworks like React.js, Next.js, Vue.js, and Angular.js.",
            "React applications commonly use JSX, an XML-like syntax extension to JavaScript. To transpile JSX into plain JavaScript, we can rely on the @babel/preset-react preset. This transformation enables even the most advanced React applications to maintain browser compatibility.",
            "Next.js, a popular React framework, inherently supports Babel. Basic usage requires no additional configuration, but if you want to customize Babel’s behavior, you can create a .babelrc file at the root of your project. Next.js blends this configuration with its default, allowing you to adopt the latest JavaScript features without losing compatibility.",
            "For Vue.js projects, Babel comes integrated out-of-the-box when generated via Vue CLI. Whether you use ES6+ JavaScript or Vue’s Single File Components (SFCs) in a Vue file, Babel smoothly transpiles them.",
            "Although Angular.js projects typically don’t use Babel as TypeScript is the preferred language, the philosophy behind Babel’s operation is still applicable. Angular employs TypeScript’s compiler “tsc” to compile TypeScript down to ES5, a role similar to Babel."
          ]
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "Setting Up Babel: First Steps",
          "paragraphs": [
            "For this article, we will focus on the setup on React.js projects, the most popular framework for web application. Our React preset can help you get started. For an enhanced syntax highlighting experience, pair it with the babel-sublime package.",
            "To install this preset, use the following command:"
          ]
        },
        {
          "id": "5",
          "type": "CODE",
          "code": "yarn add --dev @babel/preset-react"
        },
        {
          "id": "6",
          "type": "TEXT",
          "paragraphs": [
            "Then, add @babel/preset-react to your Babel configuration."
          ]
        },
        {
          "id": "7",
          "type": "TEXT",
          "title": "Type Annotations (Flow and TypeScript)",
          "paragraphs": [
            "Babel can strip out type annotations! Get started with our Flow preset or TypeScript preset. It’s important to remember that Babel doesn’t perform type checking; for that, you’ll still need to install and use Flow or TypeScript.",
            "Install the flow preset with:"
          ]
        },
        {
          "id": "8",
          "type": "CODE",
          "code": "yarn add --dev @babel/preset-flow"
        },
        {
          "id": "9",
          "type": "TEXT",
          "paragraphs": [
            "Or, install the typescript preset with:"
          ]
        },
        {
          "id": "10",
          "type": "CODE",
          "code": "yarn add --dev @babel/preset-typescript"
        },
        {
          "id": "11",
          "type": "TEXT",
          "title": "Pluggable",
          "paragraphs": [
            "Babel is built on plugins. You can compose your transformation pipeline using existing plugins or create your own. A set of plugins can easily be used by using or creating a preset."
          ]
        },
        {
          "id": "12",
          "type": "TEXT",
          "title": "Debuggable",
          "paragraphs": [
            "Babel supports source maps, simplifying the process of debugging your compiled code."
          ]
        },
        {
          "id": "13",
          "type": "TEXT",
          "title": "Spec Compliant",
          "paragraphs": [
            "Babel aims to adhere to the ECMAScript standard as closely as possible. There may be specific options for increasing spec compliance at the expense of performance."
          ]
        },
        {
          "id": "14",
          "type": "TEXT",
          "title": "Compact",
          "paragraphs": [
            "Babel strives to use the least amount of code possible without relying on a bulky runtime. “Assumptions” options are available that trade-off spec compliance for readability, file size, and speed."
          ]
        },
        {
          "id": "15",
          "type": "TEXT",
          "title": "Usage Guide",
          "paragraphs": [
            "The Babel toolchain encompasses several tools designed to make it easy for both end-users and those building Babel integrations. This introduction provides a quick overview of these tools, but you can find more detailed information in the “Usage” section of the docs.",
            "If you’re using a framework, configuring Babel might be different or might already be done for you. In such cases, check out our interactive setup guide."
          ]
        },
        {
          "id": "16",
          "type": "TEXT",
          "title": "Babel’s Configuration File",
          "paragraphs": [
            "Babel’s configuration file, .babelrc or babel.config.json, is where you specify your application's needs. You can define the presets and plugins you want to use, as well as the targets (browser environments) you're developing for."
          ]
        },
        {
          "id": "17",
          "type": "TEXT",
          "title": "Guaranteeing Browser Compatibility",
          "paragraphs": [
            "A key feature of Babel is ensuring that your modern JavaScript code works seamlessly across a wide range of browsers. It achieves this by transforming your code into a version that older browsers can understand. To specify the browsers your application needs to support, you can use the browser list field in your package.json file:"
          ]
        },
        {
          "id": "18",
          "type": "CODE",
          "code": "{ \n  \"browserslist\": \"> 0.25%, not dead\" \n}"
        },
        {
          "id": "19",
          "type": "TEXT",
          "paragraphs": [
            "This line states that your application seeks to support any browser used by more than 0.25% of people and those browsers that are not “dead” or no longer in use.\n\n"
          ]
        },
        {
          "id": "20",
          "type": "TEXT",
          "title": "Enhancing Babel’s Capabilities",
          "paragraphs": [
            "Consider investigating Babel plugins that can optimize your code. For example, the @babel/plugin-transform-runtime plugin avoids duplication in the compiled output.",
            "Another key plugin is @babel/plugin-proposal-class-properties that allows class properties in JavaScript, commonly used in React components."
          ]
        },
        {
          "id": "21",
          "type": "TEXT",
          "title": "Conclusion: Embracing Babel as a Web Developer",
          "paragraphs": [
            "Babel acts as the bridge between the innovative, fast-paced world of JavaScript updates and the stable, reliable demand for cross-browser compatibility. By understanding how it works, you can leverage its power and flexibility to create robust, versatile web applications.",
            "Remember, mastering a tool like Babel requires practice and patience. Don’t hesitate to dive into the documentation, experiment with your code, and learn from your experiences. Babel might seem complex, but once you grasp its potential, it becomes a valuable asset in your web development toolkit.",
            "Happy coding!"
          ]
        }
      ]
    },
    {
      "id": "6",
      "title": "The Battle of the Front-End Frameworks: React vs Angular",
      "img": "https://miro.medium.com/v2/resize:fit:720/format:webp/1*tvO0SIw1hVduIXFFmZJw4A.png",
      "views": 999,
      "createdAt": "06.19.2023",
      "userId": "1",
      "type": [
        "IT",
        "React"
      ],
      "blocks": [
        {
          "id": "1",
          "type": "TEXT",
          "paragraphs": [
            "React, and Angular are two of the most popular front-end web development frameworks in the world. Both frameworks are open-source, feature-rich, and widely adopted by developers. In addition, they are powerful tools that allow developers to create dynamic, scalable web applications. However, choosing between React and Angular can take time, as both frameworks have pros and cons. In this article, we’ll compare React and Angular, their features, use cases, and community support to help you decide which framework best fits your project."
          ]
        },
        {
          "id": "2",
          "type": "TEXT",
          "title": "React: A Brief Overview",
          "paragraphs": [
            "React is a JavaScript library developed by Facebook that enables developers to build reusable and interactive UI components for web applications. React’s main advantage is that it’s fast, efficient, and easy to learn. In addition, it uses a virtual DOM, which allows it to update the UI efficiently without having to re-render the entire page. This makes React ideal for building large, complex web applications. React also has a large and active community that provides developers with a wealth of support, resources, and documentation."
          ]
        },
        {
          "id": "3",
          "type": "TEXT",
          "title": "Angular: A Brief Overview",
          "paragraphs": [
            "Angular, on the other hand, is a full-featured framework for building complex web applications. Google developed it, and it is often called “Angular 2+” to distinguish it from its predecessor, AngularJS. Angular uses a declarative syntax and component-based architecture to create reusable UI components. It also provides robust features such as dependency injection, two-way data binding, and observables, which make it an excellent choice for building large-scale enterprise applications. In addition, angular has a large and active community with a vast library of tools, resources, and documentation."
          ]
        },
        {
          "id": "4",
          "type": "TEXT",
          "title": "Features Comparison",
          "paragraphs": [
            "React, and Angular have unique features that set them apart. Here’s a quick comparison of the most significant features of each framework:"
          ]
        },
        {
          "id": "5",
          "type": "TEXT",
          "title": "React:",
          "paragraphs": [
            "• Lightweight and easy to learn",
            "• Fast and efficient rendering using the virtual DOM",
            "• Strong community support with a vast library of third-party tools and packages",
            "• Supports both server-side and client-side rendering",
            "• Well-suited for building single-page applications (SPAs)"
          ]
        },
        {
          "id": "6",
          "type": "TEXT",
          "title": "Angular:",
          "paragraphs": [
            "• Robust features such as dependency injection, two-way data binding, and observables",
            "• Full-featured framework with everything you need to build complex web applications",
            "• Highly scalable architecture with support for large-scale enterprise applications",
            "• Built-in support for unit testing and end-to-end testing",
            "• Strong support for building Progressive Web Applications (PWAs)"
          ]
        },
        {
          "id": "7",
          "type": "TEXT",
          "title": "Use Cases",
          "paragraphs": [
            "Comparison Both React and Angular have a wide range of use cases. React is ideal for building lightweight, single-page applications (SPAs), while Angular is better suited for building large-scale enterprise applications. Here’s a quick comparison of the use cases for each framework:"
          ]
        },
        {
          "id": "8",
          "type": "TEXT",
          "title": "React:",
          "paragraphs": [
            "• Building lightweight, single-page applications (SPAs)",
            "• Creating reusable UI components for web applications",
            "• Developing real-time applications such as chat or messaging apps",
            "• Building mobile apps using React Native"
          ]
        },
        {
          "id": "9",
          "type": "TEXT",
          "title": "Angular:",
          "paragraphs": [
            "• Building large-scale enterprise applications",
            "• Developing complex, data-intensive applications",
            "• Creating Progressive Web Applications (PWAs)",
            "• Building cross-platform mobile apps using Ionic or NativeScript"
          ]
        },
        {
          "id": "10",
          "type": "TEXT",
          "title": "Use Cases",
          "paragraphs": [
            "Both React and Angular have large and active communities that provide developers with a wealth of support, resources, and documentation. However, the communities for each framework are different. Here is a quick comparison of the community support for each framework:"
          ]
        },
        {
          "id": "11",
          "type": "TEXT",
          "title": "React:",
          "paragraphs": [
            "• Large and active community with a vast library of third-party tools and packages",
            "• Lots of online resources, tutorials, and documentation are available.",
            "• React is widely adopted by companies such as Facebook, Netflix, and Airbnb, which provides additional support and resources.",
            "• React’s community is generally more focused on the front-end development and UI aspect of web development."
          ]
        },
        {
          "id": "12",
          "type": "TEXT",
          "title": "Angular:",
          "paragraphs": [
            "• Large and active community with a vast library of third-party tools and packages",
            "• Lots of online resources, tutorials, and documentation are available.",
            "• Angular is widely adopted by companies such as Google, Microsoft, and IBM, which provides additional support and resources.",
            "• Angular’s community is generally more focused on web applications’ overall architecture and scalability."
          ]
        },
        {
          "id": "13",
          "type": "TEXT",
          "title": "Conclusion: Which Framework Should You Choose?",
          "paragraphs": [
            "In conclusion, both React and Angular are excellent front-end development frameworks, and the choice between them ultimately depends on the specific requirements of your project. React is a lightweight, easy-to-learn library for building SPAs and real-time applications. It has a strong community and is widely adopted by companies like Facebook, Netflix, and Airbnb.",
            "On the other hand, Angular is a full-featured framework that’s ideal for building large-scale enterprise applications. It has robust features such as dependency injection, two-way data binding, and observables, and it’s widely adopted by companies such as Google, Microsoft, and IBM. It’s also well-suited for building PWAs and cross-platform mobile apps using Ionic or NativeScript.",
            "Ultimately, it’s essential to choose the framework that best fits your project’s requirements and the skills of your development team. However, regardless of your choice, React and Angular are excellent tools that can help you build dynamic and scalable web applications."
          ]
        }
      ]
    }
  ],
  "comments": [
    {
      "id": "1",
      "text": "some comment",
      "articleId": "1",
      "userId": "1"
    },
    {
      "articleId": "1",
      "userId": "1",
      "text": "123123123",
      "id": "hXqu-Ka"
    }
  ],
  "users": [
    {
      "id": "1",
      "username": "admin",
      "password": "123",
      "roles": [
        "ADMIN"
      ],
      "features": {
        "isArticleRatingEnabled": true,
        "isAppRedesigned": true
      },
      "jsonSettings": {
        "theme": "app_light_theme",
        "isArticlesPageWasOpened": true
      },
      "avatar": "https://pic.rutubelist.ru/user/3b/27/3b2758ad5492a76b578f7ee072e4e894.jpg"
    }
  ],
  "profile": [
    {
      "id": "1",
      "firstname": "Oliver",
      "lastname": "Kezik",
      "age": 25,
      "currency": "RUB",
      "country": "Russia",
      "city": "New York",
      "username": "okezik",
      "avatar": "https://pic.rutubelist.ru/user/3b/27/3b2758ad5492a76b578f7ee072e4e894.jpg"
    }
  ],
  "article-ratings": [
    {
      "id": "1",
      "rate": 4,
      "feedback": "Хорошая статья",
      "userId": "1",
      "articleId": "1"
    },
    {
      "userId": "1",
      "articleId": "7",
      "rate": 3,
      "id": "6xAjc8g"
    },
    {
      "userId": "1",
      "articleId": "4",
      "rate": 3,
      "feedback": "",
      "id": "xsmLSeK"
    }
  ],
  "profile-ratings": [
    {
      "id": "1",
      "rate": 4,
      "feedback": "Хорошая статья",
      "userId": "1",
      "profileId": "1"
    }
  ]
}